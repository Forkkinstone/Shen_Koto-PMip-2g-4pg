#include <iostream>          
#include <vector>            
#include <queue>             // Для реализации очереди в BFS
#include <utility>           // Для использования std::pair
using namespace std;   
      
// Направления движения по восьми соседним клеткам (включая диагонали)
const int dx[8] = {-1, -1, -1, 0, 1, 1, 1, 0};  // Смещения по строкам
const int dy[8] = {-1, 0, 1, 1, 1, 0, -1, -1};  // Смещения по столбцам

int main() {
    int N, M;                                    // Размеры поля
    cin >> N >> M;                               // Считываем количество строк и столбцов
    vector<vector<char>> grid(N, vector<char>(M)); // Создаем поле размером N x M

    pair<int, int> start, end;                   // Пары для хранения координат 'S' и 'E'

    // Считываем поле
    for (int i = 0; i < N; ++i) {               // Проходим по каждой строке
        for (int j = 0; j < M; ++j) {           // Проходим по каждому столбцу
            cin >> grid[i][j];                  // Считываем символ клетки
            if (grid[i][j] == 'S') {            // Если нашли начальную клетку
                start = {i, j};                 // Сохраняем координаты 'S'
            } else if (grid[i][j] == 'E') {     // Если нашли конечную клетку
                end = {i, j};                   // Сохраняем координаты 'E'
            }
        }
    }

    // Матрица для хранения расстояний до каждой клетки
    vector<vector<int>> dist(N, vector<int>(M, -1)); // Инициализируем все расстояния как -1
    queue<pair<int, int>> q;                          // Очередь для BFS

    dist[start.first][start.second] = 0;             // Расстояние до начальной клетки равно 0
    q.push(start);                                   // Добавляем начальную клетку в очередь

    // Алгоритм поиска в ширину (BFS)
    while (!q.empty()) {                             // Пока очередь не пуста
        auto current = q.front();                    // Берем первый элемент из очереди
        q.pop();                                     // Удаляем его из очереди

        // Если достигли конечной клетки, то завершаем поиск
        if (current == end) {
            break;
        }

        // Проверяем всех соседей текущей клетки
        for (int k = 0; k < 8; ++k) {                // Проходим по всем 8 направлениям
            int x = current.first + dx[k];           // Новая координата по строке
            int y = current.second + dy[k];          // Новая координата по столбцу

            // Проверяем, что новые координаты внутри поля и клетка проходима
            if (x >= 0 && x < N && y >= 0 && y < M && grid[x][y] != '#' && dist[x][y] == -1) {
                dist[x][y] = dist[current.first][current.second] + 1; // Обновляем расстояние
                q.push({x, y});                                       // Добавляем клетку в очередь
            }
        }
    }

    // Выводим результат
    cout << dist[end.first][end.second] << endl;    // Минимальное количество шагов или -1, если недостижимо

    return 0;                                       // Завершаем программу
}
